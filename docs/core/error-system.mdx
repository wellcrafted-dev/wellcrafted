---
title: 'Error System Design'
description: "Understanding wellcrafted's structured, serializable error system"
icon: 'triangle-exclamation'
---

# Error System Design

wellcrafted's error system is built on a simple yet powerful principle: **errors should be data, not control flow**. This page explains the design philosophy, implementation details, and best practices for creating robust error handling in your applications.

## The TaggedError Pattern

At the heart of wellcrafted's error system is the `TaggedError` type - a structured, serializable error representation that works seamlessly with TypeScript's type system.

### Why TaggedError?

Traditional JavaScript errors have fundamental problems:

1. **Serialization breaks them**: `JSON.stringify(new Error())` loses the message and stack trace
2. **No standardization**: Libraries throw strings, Error objects, custom classes, or even undefined
3. **Prototype chain complexity**: `instanceof` checks fail across different realms (iframes, workers)
4. **Poor TypeScript integration**: Can't discriminate between different error types in unions

TaggedError solves all these issues:

1. **JSON-serializable**: Plain objects that survive any serialization boundary
2. **Type-safe discrimination**: The `name` field acts as a discriminant for TypeScript
3. **Lightweight**: No overhead of class instantiation or prototype chains
4. **Flat structure**: Fields are spread directly on the error object — no nesting

## The TaggedError Type

Every `TaggedError` has a `name` and `message`, plus any additional fields spread flat on the object:

```typescript
type TaggedError<
  TName extends string = string,
  TFields extends JsonObject = Record<never, never>,
> = Readonly<{ name: TName; message: string } & TFields>;
```

The minimal type for any tagged error is:

```typescript
type AnyTaggedError = { name: string; message: string };
```

### `name` — The Discriminant

This is your error's unique identifier and the key to pattern matching. Use it in `if` statements and `switch` statements to handle different error types:

```typescript
type ValidationError = TaggedError<"ValidationError", { field: string }>;
type NetworkError = TaggedError<"NetworkError", { url: string }>;
type FileError = TaggedError<"FileError", { path: string }>;

function handleError(error: ValidationError | NetworkError | FileError) {
  switch (error.name) {
    case "ValidationError":
      // TypeScript knows this is ValidationError
      console.log("Invalid input:", error.field);
      break;
    case "NetworkError":
      // TypeScript knows this is NetworkError
      console.log("Network failed:", error.url);
      break;
    case "FileError":
      // TypeScript knows this is FileError
      console.log("File issue:", error.path);
      break;
  }
}
```

### `message` — Human-Readable Text

The message is **computed by the template function** you provide to `.withMessage()`. You never pass a message at the call site — it is always derived from the fields:

```typescript
const { ValidationError, ValidationErr } = createTaggedError('ValidationError')
  .withFields<{ email: string }>()
  .withMessage(({ email }) => `Email address "${email}" must contain an @ symbol`);

return ValidationErr({ email: userInput });
```

### Fields — Flat on the Error Object

Additional data is spread directly on the error object, not nested under a `context` property. This makes access natural and concise:

```typescript
const { ProcessError, ProcessErr } = createTaggedError('ProcessError')
  .withFields<{ userId: number; timestamp: string; retryCount: number }>()
  .withMessage(() => 'User processing failed');

function processUser(id: number): Result<User, ProcessError> {
  return ProcessErr({
    userId: id,
    timestamp: new Date().toISOString(),
    retryCount: 3
  });
}

// Access fields directly:
// error.userId, error.timestamp, error.retryCount
```

<Note>
Fields should include the function's input parameters and any relevant debugging information. Since they are spread flat on the error object, you get direct access — `error.userId` instead of `error.context.userId`.
</Note>

## The Three Tiers

The `createTaggedError` builder supports three tiers of complexity:

### Tier 1: Static Error (No Fields)

For errors where the message is always the same and no additional data is needed:

```typescript
const { RecorderBusyError, RecorderBusyErr } = createTaggedError('RecorderBusyError')
  .withMessage(() => 'A recording is already in progress');

// No arguments at the call site
RecorderBusyErr();
// → { name: 'RecorderBusyError', message: 'A recording is already in progress' }
```

### Tier 2: Reason-Only Error

For errors that just need a human-readable reason string:

```typescript
const { PlaySoundError, PlaySoundErr } = createTaggedError('PlaySoundError')
  .withFields<{ reason: string }>()
  .withMessage(({ reason }) => `Failed to play sound: ${reason}`);

PlaySoundErr({ reason: 'Audio context not initialized' });
// → { name: 'PlaySoundError', message: 'Failed to play sound: Audio context not initialized', reason: 'Audio context not initialized' }
```

### Tier 3: Structured Data Error

For errors that carry rich, typed debugging information:

```typescript
const { ResponseError, ResponseErr } = createTaggedError('ResponseError')
  .withFields<{ status: number; reason?: string }>()
  .withMessage(({ status, reason }) =>
    `HTTP ${status}${reason ? `: ${reason}` : ''}`
  );

ResponseErr({ status: 404 });
// → { name: 'ResponseError', message: 'HTTP 404', status: 404 }

ResponseErr({ status: 500, reason: 'Internal server error' });
// → { name: 'ResponseError', message: 'HTTP 500: Internal server error', status: 500, reason: 'Internal server error' }
```

## Error Chaining

There is no dedicated `.withCause()` step. If you need to chain errors, model `cause` as just another field:

```typescript
// Define errors for each layer
const { NetworkError, NetworkErr } = createTaggedError('NetworkError')
  .withFields<{ host: string; port: number; timeout: number }>()
  .withMessage(({ timeout }) => `Socket timeout after ${timeout}ms`);
type NetworkError = ReturnType<typeof NetworkError>;

const { DatabaseError, DatabaseErr } = createTaggedError('DatabaseError')
  .withFields<{ operation: string; retries: number; cause: NetworkError }>()
  .withMessage(() => 'Failed to connect to database');
type DatabaseError = ReturnType<typeof DatabaseError>;

const { UserServiceError, UserServiceErr } = createTaggedError('UserServiceError')
  .withFields<{ userId: string; method: string; cause: DatabaseError }>()
  .withMessage(() => 'Could not fetch user profile');
type UserServiceError = ReturnType<typeof UserServiceError>;

const { APIError, APIErr } = createTaggedError('APIError')
  .withFields<{ endpoint: string; statusCode: number; cause: UserServiceError }>()
  .withMessage(() => 'Internal server error');

// Low-level network error
const networkError = NetworkError({
  host: "db.example.com", port: 5432, timeout: 5000
});

// Wrapped by database layer
const dbError = DatabaseError({
  operation: "connect", retries: 3, cause: networkError
});

// Wrapped by service layer
const serviceError = UserServiceError({
  userId: "123", method: "getUserById", cause: dbError
});

// Wrapped by API handler
const apiError = APIError({
  endpoint: "/api/users/123", statusCode: 500, cause: serviceError
});

// The entire error chain is JSON-serializable!
console.log(JSON.stringify(apiError, null, 2));
```

**The serialized output shows the complete chain:**

```json
{
  "name": "APIError",
  "message": "Internal server error",
  "endpoint": "/api/users/123",
  "statusCode": 500,
  "cause": {
    "name": "UserServiceError",
    "message": "Could not fetch user profile",
    "userId": "123",
    "method": "getUserById",
    "cause": {
      "name": "DatabaseError",
      "message": "Failed to connect to database",
      "operation": "connect",
      "retries": 3,
      "cause": {
        "name": "NetworkError",
        "message": "Socket timeout after 5000ms",
        "host": "db.example.com",
        "port": 5432,
        "timeout": 5000
      }
    }
  }
}
```

This chaining pattern provides:
- **Complete error trace**: See exactly how an error bubbled up through your stack
- **Layer-specific fields**: Each layer adds its own debugging information as flat fields
- **JSON-serializable**: Unlike JavaScript stack traces, this survives any serialization
- **Type-safe**: Each error in the chain maintains full TypeScript typing

## Creating Domain-Specific Errors

Define a set of possible errors for each domain in your application:

```typescript
// Define your specific error types
export type FileNotFoundError = TaggedError<"FileNotFoundError", { path: string }>;
export type PermissionDeniedError = TaggedError<"PermissionDeniedError", { path: string; user: string }>;
export type DiskFullError = TaggedError<"DiskFullError", { volumeName: string }>;

// Create a union of all possible errors for this domain
export type FileSystemError =
  | FileNotFoundError
  | PermissionDeniedError
  | DiskFullError;

// Use createTaggedError to define factories
const { FileNotFoundErr } = createTaggedError('FileNotFoundError')
  .withFields<{ path: string }>()
  .withMessage(({ path }) => `The file at path "${path}" was not found`);
```

## The createTaggedError API

wellcrafted provides a fluent `createTaggedError` builder that eliminates boilerplate and enforces consistent error structure. The builder requires `.withMessage(fn)` as its **final step** — this is what gives you the factory functions.

```typescript
import { createTaggedError } from "wellcrafted/error";

// Define your error — .withMessage() is required and returns the factories
const { NetworkError, NetworkErr } = createTaggedError('NetworkError')
  .withMessage(() => 'Network request failed');

// Extract the type using ReturnType
type NetworkError = ReturnType<typeof NetworkError>;

// Two factory functions are created:
// - NetworkError(): Creates plain error object
// - NetworkErr(): Creates Err-wrapped error (for Result returns)
```

### `.withMessage(fn)` — Required and Terminal

`.withMessage(fn)` is the **terminal step** of the builder. It accepts a function that receives the fields and returns the error message string. Factories are only available after calling it.

```typescript
const { FileError, FileErr } = createTaggedError('FileError')
  .withFields<{ path: string; operation: 'read' | 'write' | 'delete' }>()
  .withMessage(({ path, operation }) => `${operation} failed for ${path}`);

// Message is auto-computed from the template at call time
FileErr({ path: '/etc/passwd', operation: 'write' });
// → { name: 'FileError', message: 'write failed for /etc/passwd', path: '/etc/passwd', operation: 'write' }
```

<Note>
Factories are only available on the object returned by `.withMessage()`. The builder returned by `.withFields()` does **not** have factory methods — you must call `.withMessage()` first.
</Note>

### `.withFields<T>()` — Defining Structured Data

Use `.withFields<T>()` to define additional fields spread flat on the error object. The type `T` must be a `JsonObject` and must not include the reserved keys `name` or `message`.

#### Required Fields

When you know what information is **always** needed:

```typescript
const { FileError, FileErr } = createTaggedError('FileError')
  .withFields<{ path: string; operation: 'read' | 'write' | 'delete' }>()
  .withMessage(({ path, operation }) => `${operation} failed for ${path}`);

// Fields are REQUIRED — TypeScript enforces it
FileErr({ path: '/etc/passwd', operation: 'write' });
// FileErr();  // Type error! fields are required
```

#### Optional Fields

Use optional properties when fields are not always available:

```typescript
const { LogError, LogErr } = createTaggedError('LogError')
  .withFields<{ file?: string; line?: number }>()
  .withMessage(() => 'Log parse failed');

// No fields needed
LogErr();

// When provided, they're fully typed
LogErr({ file: 'app.ts', line: 42 });
// LogErr({ wrong: true });  // Type error! wrong shape
```

### Fields Must Be JSON-Serializable

Fields must conform to `JsonObject` — all values must be JSON-serializable primitives, arrays, or nested objects. This ensures errors survive any serialization boundary.

```typescript
// Valid JsonObject fields
FileErr({ path: '/etc/passwd', size: 1024, tags: ['system'] });

// Not allowed — Date, functions, class instances are not JSON-serializable
FileErr({ createdAt: new Date(), handler: () => {} });  // Type error!
```

### Extracting the Error Type

Use `ReturnType<typeof FactoryFn>` to get the TypeScript type for a factory:

```typescript
const { NetworkError, NetworkErr } = createTaggedError('NetworkError')
  .withFields<{ url: string; status: number }>()
  .withMessage(({ url, status }) => `Request to ${url} failed with ${status}`);

type NetworkError = ReturnType<typeof NetworkError>;
// NetworkError = TaggedError<'NetworkError', { url: string; status: number }>
```

### Quick Reference

```typescript
import { createTaggedError } from 'wellcrafted/error';

// Tier 1: Static — no fields, no args at call site
const { NetworkError, NetworkErr } = createTaggedError('NetworkError')
  .withMessage(() => 'Network request failed');

// Tier 2: Reason-only
const { ParseError, ParseErr } = createTaggedError('ParseError')
  .withFields<{ reason: string }>()
  .withMessage(({ reason }) => `Parse failed: ${reason}`);

// Tier 3: Structured data
const { FileError, FileErr } = createTaggedError('FileError')
  .withFields<{ path: string; operation: string }>()
  .withMessage(({ path, operation }) => `File ${operation} failed: ${path}`);

// Structured with optional fields
const { LogError, LogErr } = createTaggedError('LogError')
  .withFields<{ file?: string; line?: number }>()
  .withMessage(() => 'Log parse failed');

// Chaining via cause field
const { ServiceError, ServiceErr } = createTaggedError('ServiceError')
  .withFields<{ endpoint: string; cause?: NetworkError }>()
  .withMessage(({ endpoint }) => `Service call failed: ${endpoint}`);

// Extract types
type NetworkError = ReturnType<typeof NetworkError>;
type FileError = ReturnType<typeof FileError>;
```

### Using in tryAsync/trySync

The factory pattern works seamlessly with error mapping. Pass fields at the call site — the message is auto-computed by `.withMessage()`:

```typescript
const { ApiError, ApiErr } = createTaggedError('ApiError')
  .withFields<{ endpoint: string }>()
  .withMessage(({ endpoint }) => `Failed to fetch data from ${endpoint}`);

const result = await tryAsync({
  try: () => fetch('/api/data').then(r => r.json()),
  catch: () => ApiErr({ endpoint: '/api/data' })
});
```

## Serialization Benefits

Unlike JavaScript's Error class, TaggedErrors are plain objects that serialize perfectly:

```typescript
const { ValidationError } = createTaggedError('ValidationError')
  .withFields<{ field: string; value: number; min: number; max: number }>()
  .withMessage(({ field, min, max }) => `${field} must be between ${min} and ${max}`);

const error = ValidationError({
  field: "age", value: -5, min: 0, max: 150
});

// Perfect serialization
const serialized = JSON.stringify(error);
console.log(serialized);
// {"name":"ValidationError","message":"age must be between 0 and 150","field":"age","value":-5,"min":0,"max":150}

// Perfect deserialization
const deserialized = JSON.parse(serialized);
// Still a valid TaggedError!
```

This enables:
- **API responses**: Send structured errors to clients
- **Logging**: Store complete error information
- **Worker communication**: Pass errors between threads
- **State persistence**: Save errors in localStorage or databases

## Best Practices

### 1. Include Meaningful Fields

Always start with the function's input parameters:

```typescript
const { DbError, DbErr } = createTaggedError('DbError')
  .withFields<{ query: string; params: unknown[]; timestamp: string; connectionPool: string }>()
  .withMessage(({ query }) => `Database query failed: ${query}`);

// At the call site — fields capture function inputs and debugging info
DbErr({
  query: 'SELECT * FROM users WHERE id = ?',  // Function input
  params: [userId],                             // Function input
  timestamp: new Date().toISOString(),          // Additional context
  connectionPool: 'primary'                     // Debugging info
});
```

### 2. Make Errors Specific

Avoid generic error types:

```typescript
// Too generic
type Error = TaggedError<"Error">;

// Specific and actionable
type UserNotFoundError = TaggedError<"UserNotFoundError", { userId: string }>;
type InvalidCredentialsError = TaggedError<"InvalidCredentialsError", { username: string }>;
type SessionExpiredError = TaggedError<"SessionExpiredError", { sessionId: string }>;
```

### 3. Use Union Types for Function Signatures

Make all possible errors visible:

```typescript
function authenticateUser(
  credentials: Credentials
): Result<User, InvalidCredentialsError | UserNotFoundError | SessionExpiredError> {
  // Implementation makes it clear what can go wrong
}
```

### 4. Handle Errors at the Right Level

Transform errors where you can add context:

```typescript
const { UserServiceErr } = createTaggedError('UserServiceError')
  .withFields<{ userId: string; operation: string; cause: DbError }>()
  .withMessage(({ operation }) => `Failed to ${operation}`);

async function getUserProfile(userId: string): Result<Profile, UserServiceError> {
  const dbResult = await queryDatabase(`SELECT * FROM users WHERE id = ?`, [userId]);

  if (dbResult.error) {
    return UserServiceErr({
      userId,
      operation: 'getUserProfile',
      cause: dbResult.error
    });
  }

  return Ok(transformToProfile(dbResult.data));
}
```

### 5. Design for Debugging

Structure your errors to answer these questions:
- **What went wrong?** (message)
- **Where did it happen?** (name)
- **What data caused it?** (fields)
- **What was the root cause?** (cause field if chained)

```typescript
const { PaymentErr } = createTaggedError('PaymentError')
  .withFields<{ orderId: string; amount: number; cardLast4: string; cause: CardValidationError }>()
  .withMessage(() => 'Payment processing failed');

function processPayment(order: Order, card: Card): Result<Receipt, PaymentError> {
  const validation = validateCard(card);
  if (validation.error) {
    return PaymentErr({
      orderId: order.id,
      amount: order.total,
      cardLast4: card.number.slice(-4),
      cause: validation.error
    });
  }
  // ... rest of implementation
}
```

## Error Handling Patterns

### Early Return Pattern

The most common and readable pattern:

```typescript
async function createOrder(input: OrderInput): Promise<Result<Order, OrderError>> {
  const userResult = await getUser(input.userId);
  if (userResult.error) return userResult;

  const validationResult = validateOrderInput(input);
  if (validationResult.error) return validationResult;

  const inventoryResult = await checkInventory(input.items);
  if (inventoryResult.error) return inventoryResult;

  // All checks passed, create the order
  return Ok(await saveOrder({
    user: userResult.data,
    items: inventoryResult.data,
    ...validationResult.data
  }));
}
```

### Error Aggregation

When you need to collect multiple errors:

```typescript
const { ValidationError } = createTaggedError('ValidationError')
  .withFields<{ field: string; value?: string }>()
  .withMessage(({ field }) => `Validation failed for field "${field}"`);
type ValidationError = ReturnType<typeof ValidationError>;

function validateForm(input: FormInput): Result<ValidatedForm, ValidationError[]> {
  const errors: ValidationError[] = [];

  if (!input.email?.includes('@')) {
    errors.push(ValidationError({ field: 'email', value: input.email }));
  }

  if (!input.password || input.password.length < 8) {
    errors.push(ValidationError({ field: 'password' }));
  }

  if (errors.length > 0) {
    return Err(errors);
  }

  return Ok(input as ValidatedForm);
}
```

### Error Recovery

Implement retry logic with typed errors:

```typescript
const { NetworkError, NetworkErr } = createTaggedError('NetworkError')
  .withFields<{ url: string; attempt: number; maxRetries: number }>()
  .withMessage(({ attempt, maxRetries }) => `Request failed (attempt ${attempt}/${maxRetries})`);
type NetworkError = ReturnType<typeof NetworkError>;

async function fetchWithRetry<T>(
  url: string,
  maxRetries = 3
): Promise<Result<T, NetworkError>> {
  let lastError: NetworkError | null = null;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    const result = await tryAsync<T, NetworkError>({
      try: () => fetch(url).then(r => r.json()),
      catch: () => NetworkErr({ url, attempt, maxRetries })
    });

    if (result.data) return result;

    lastError = result.error;

    // Exponential backoff
    if (attempt < maxRetries) {
      await new Promise(resolve =>
        setTimeout(resolve, Math.pow(2, attempt) * 1000)
      );
    }
  }

  return Err(lastError!);
}
```

## Integration with Result Type

TaggedErrors are designed to work seamlessly with the Result type:

```typescript
import { Result, Ok, Err, tryAsync } from "wellcrafted/result";
import { createTaggedError } from "wellcrafted/error";

const { DatabaseError, DatabaseErr } = createTaggedError('DatabaseError')
  .withFields<{ userId: string; operation: string }>()
  .withMessage(({ operation }) => `Database ${operation} failed`);
type DatabaseError = ReturnType<typeof DatabaseError>;

const { UserNotFoundError, UserNotFoundErr } = createTaggedError('UserNotFoundError')
  .withFields<{ userId: string }>()
  .withMessage(({ userId }) => `User with ID ${userId} not found`);
type UserNotFoundError = ReturnType<typeof UserNotFoundError>;

async function getUser(id: string): Promise<Result<User, UserNotFoundError | DatabaseError>> {
  const result = await tryAsync<User, DatabaseError>({
    try: () => database.users.findById(id),
    catch: () => DatabaseErr({ userId: id, operation: 'findById' })
  });

  if (result.error) return result;

  if (!result.data) {
    return UserNotFoundErr({ userId: id });
  }

  return Ok(result.data);
}
```

## Summary

The TaggedError system transforms error handling from an afterthought to a first-class concern:

- **Structured**: Every error has a consistent shape with `name` and `message`
- **Flat**: Fields are spread directly on the error object — no nesting
- **Serializable**: Works across all JavaScript boundaries
- **Type-safe**: Full TypeScript discrimination support
- **Debuggable**: Rich fields for troubleshooting
- **Composable**: Errors can be chained via cause fields

By treating errors as data rather than control flow, you gain predictability, testability, and maintainability in your error handling.

## See Also

<CardGroup>
  <Card title="Result Pattern Deep Dive" icon="code-branch" href="/core/result-pattern">
    Understand how TaggedErrors work with the Result discriminated union
  </Card>
  <Card title="Real-World Examples" icon="code" href="/patterns/real-world">
    See TaggedErrors in production authentication, validation, and API code
  </Card>
  <Card title="Service Layer Pattern" icon="layer-group" href="/patterns/service-layer">
    Learn error transformation patterns in service architecture
  </Card>
  <Card title="Framework Integrations" icon="plug" href="/integrations/svelte-tanstack">
    Use TaggedErrors with TanStack Query and other frameworks
  </Card>
</CardGroup>

<Note>
Ready to see TaggedErrors in action? Explore our [real-world patterns](/patterns/real-world) or check out the [service layer guide](/patterns/service-layer).
</Note>
