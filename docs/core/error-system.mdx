---
title: 'Error System Design'
description: "Understanding wellcrafted's structured, serializable error system"
icon: 'triangle-exclamation'
---

# Error System Design

wellcrafted's error system is built on a simple yet powerful principle: **errors should be data, not control flow**. This page explains the design philosophy, implementation details, and best practices for creating robust error handling in your applications.

## The TaggedError Pattern

At the heart of wellcrafted's error system is the `TaggedError` type - a structured, serializable error representation that works seamlessly with TypeScript's type system.

### Why TaggedError?

Traditional JavaScript errors have fundamental problems:

1. **Serialization breaks them**: `JSON.stringify(new Error())` loses the message and stack trace
2. **No standardization**: Libraries throw strings, Error objects, custom classes, or even undefined
3. **Prototype chain complexity**: `instanceof` checks fail across different realms (iframes, workers)
4. **Poor TypeScript integration**: Can't discriminate between different error types in unions

TaggedError solves all these issues:

1. **JSON-serializable**: Plain objects that survive any serialization boundary
2. **Type-safe discrimination**: The `name` field acts as a discriminant for TypeScript
3. **Lightweight**: No overhead of class instantiation or prototype chains
4. **Structured context**: Enforces machine-readable debugging information

## The Four Properties of TaggedError

Every `TaggedError` contains four essential properties that work together to create a robust, debuggable error system:

```typescript
type TaggedError<T extends string> = {
  readonly name: T;                    // 1. The discriminant
  message: string;                     // 2. Human-readable description
  context?: Record<string, unknown>;   // 3. Function inputs & debugging data
  cause?: TaggedError;                 // 4. Root cause (another TaggedError)
};
```

<Note>
The `context` property should include the function's input parameters and any relevant variables in the closure. This creates a complete picture of what data led to the error, making debugging straightforward.
</Note>

### 1. `name` - The Discriminant

This is your error's unique identifier and the key to pattern matching. Use it in `if` statements and `switch` statements to handle different error types:

```typescript
type ValidationError = TaggedError<"ValidationError">;
type NetworkError = TaggedError<"NetworkError">;
type FileError = TaggedError<"FileError">;

function handleError(error: ValidationError | NetworkError | FileError) {
  switch (error.name) {
    case "ValidationError":
      // TypeScript knows this is ValidationError
      console.log("Invalid input:", error.context);
      break;
    case "NetworkError": 
      // TypeScript knows this is NetworkError
      console.log("Network failed:", error.message);
      break;
    case "FileError":
      // TypeScript knows this is FileError
      console.log("File issue:", error.context);
      break;
  }
}
```

### 2. `message` - Human-Readable Text

Pure text description that explains what went wrong. Keep it clear and actionable:

```typescript
return Err({
  name: "ValidationError",
  message: "Email address must contain an @ symbol",  // Clear, specific
  context: { email: userInput },
  cause: undefined
});
```

### 3. `context` - Function Inputs & Debugging Data

The primary purpose of `context` is to capture the function's input parameters, relevant variables in the closure, and additional context:

```typescript
function processUser(id: number, options: UserOptions): Result<User, ProcessError> {
  return Err({
    name: "ProcessError",
    message: "User processing failed",
    context: {
      userId: id,           // Function input
      options,              // Function input  
      timestamp: new Date().toISOString(),  // Additional context
      retryCount: 3         // Useful debugging info
    },
    cause: undefined
  });
}
```

### 4. `cause` - JSON-Serializable Call Stack

The `cause` property accepts another `TaggedError`, enabling error chaining. This creates a **JSON-serializable call stack** that traces how an error propagated through your application layers:

```typescript
// Low-level network error
const networkError = {
  name: "NetworkError",
  message: "Socket timeout after 5000ms",
  context: { host: "db.example.com", port: 5432, timeout: 5000 }
} satisfies TaggedError;

// Wrapped by database layer
const dbError = {
  name: "DatabaseError",
  message: "Failed to connect to database",
  context: { operation: "connect", retries: 3 },
  cause: networkError  // Chain the network error
} satisfies TaggedError;

// Wrapped by service layer
const serviceError = {
  name: "UserServiceError",
  message: "Could not fetch user profile",
  context: { userId: "123", method: "getUserById" },
  cause: dbError  // Chain the database error
} satisfies TaggedError;

// Wrapped by API handler
const apiError = {
  name: "APIError",
  message: "Internal server error",
  context: { endpoint: "/api/users/123", statusCode: 500 },
  cause: serviceError  // Chain the service error
} satisfies TaggedError;

// The entire error chain is JSON-serializable!
console.log(JSON.stringify(apiError, null, 2));
```

**The serialized output shows the complete call stack:**

```json
{
  "name": "APIError",
  "message": "Internal server error",
  "context": {
    "endpoint": "/api/users/123",
    "statusCode": 500
  },
  "cause": {
    "name": "UserServiceError",
    "message": "Could not fetch user profile",
    "context": {
      "userId": "123",
      "method": "getUserById"
    },
    "cause": {
      "name": "DatabaseError",
      "message": "Failed to connect to database",
      "context": {
        "operation": "connect",
        "retries": 3
      },
      "cause": {
        "name": "NetworkError",
        "message": "Socket timeout after 5000ms",
        "context": {
          "host": "db.example.com",
          "port": 5432,
          "timeout": 5000
        }
      }
    }
  }
}
```

You can traverse this error chain in either direction:
- **Top-down**: Start at the API error and drill into the root cause
- **Bottom-up**: Each layer wraps the layer below, preserving the full context

This chaining pattern provides:
- **Complete error trace**: See exactly how an error bubbled up through your stack
- **Layer-specific context**: Each layer adds its own debugging information
- **JSON-serializable**: Unlike JavaScript stack traces, this survives any serialization
- **Type-safe**: Each error in the chain maintains full TypeScript typing

For simple errors without an underlying cause, omit the `cause` property entirely:

```typescript
return Err({
  name: "ValidationError",
  message: "Invalid email format",
  context: { email: userInput }
  // No cause - this is where the error originated
});

## Creating Domain-Specific Errors

Define a set of possible errors for each domain in your application:

```typescript
// Define your specific error types
export type FileNotFoundError = TaggedError<"FileNotFoundError">;
export type PermissionDeniedError = TaggedError<"PermissionDeniedError">;
export type DiskFullError = TaggedError<"DiskFullError">;

// Create a union of all possible errors for this domain
export type FileSystemError = 
  | FileNotFoundError 
  | PermissionDeniedError 
  | DiskFullError;

// Factory functions to create errors
function createFileNotFoundError(path: string, cause?: unknown): FileNotFoundError {
  return {
    name: "FileNotFoundError",
    message: `The file at path "${path}" was not found.`,
    context: { path },
    cause
  };
}
```

## The createTaggedError API

wellcrafted provides a fluent `createTaggedError` function that eliminates boilerplate while giving you full control over type constraints. It's designed around a key principle: **flexible by default, constrain when needed**.

```typescript
import { createTaggedError } from "wellcrafted/error";

// Define your error
const { NetworkError, NetworkErr } = createTaggedError('NetworkError');
type NetworkError = ReturnType<typeof NetworkError>;

// Two factory functions are created:
// - NetworkError(): Creates plain error object
// - NetworkErr(): Creates Err-wrapped error (for Result returns)
```

### Default Behavior: Flexible Mode

When you call `createTaggedError` without chaining, you get **flexible mode**:

```typescript
const { NetworkError, NetworkErr } = createTaggedError('NetworkError');

// Just a message - context and cause are optional
NetworkError({ message: 'Connection timeout' });

// Add context as needed - accepts any Record<string, unknown>
NetworkError({
  message: 'DNS lookup failed',
  context: { host: 'api.example.com', timeout: 5000 }
});

// Chain errors when debugging - accepts any AnyTaggedError
NetworkError({
  message: 'Request failed',
  cause: previousError
});

// All three together
NetworkError({
  message: 'API unreachable',
  context: { endpoint: '/users', retries: 3 },
  cause: socketError
});
```

**In flexible mode:**
- `context` is **optional** and accepts any `Record<string, unknown>`
- `cause` is **optional** and accepts any `AnyTaggedError`

This is ideal for rapid development, wrapping unpredictable third-party errors, or when different call sites need different context shapes.

### Adding Type Constraints with Chaining

Use `.withContext<T>()` and `.withCause<T>()` to add type constraints when you need them.

#### Required Context: `.withContext<T>()`

When you know what debugging information is **always** needed:

```typescript
const { FileError, FileErr } = createTaggedError('FileError')
  .withContext<{ path: string; operation: 'read' | 'write' | 'delete' }>();

// Context is now REQUIRED
FileError({
  message: 'Permission denied',
  context: { path: '/etc/passwd', operation: 'write' }  // Must provide this!
});

// FileError({ message: 'Oops' });  // Type error! context is required
```

Every file error without a path is useless for debugging. Required context makes it impossible to forget this information.

#### Optional Typed Context: `.withContext<T | undefined>()`

When context is helpful but not always available, include `undefined` in the union:

```typescript
const { LogError, LogErr } = createTaggedError('LogError')
  .withContext<{ file: string; line: number } | undefined>();

// Context is optional
LogError({ message: 'Parse failed' });

// But when provided, it's fully typed
LogError({ message: 'Parse failed', context: { file: 'app.ts', line: 42 } });

// LogError({ message: 'x', context: { wrong: true } });  // Type error! wrong shape
```

This differs from flexible mode: flexible mode accepts **any** shape, while optional typed mode enforces the **exact** shape when context is present.

#### Typed Cause: `.withCause<T>()`

When errors have predictable causes:

```typescript
const { NetworkError } = createTaggedError('NetworkError');
type NetworkError = ReturnType<typeof NetworkError>;

const { ApiError, ApiErr } = createTaggedError('ApiError')
  .withCause<NetworkError | undefined>();

// Cause is optional, but if provided, MUST be NetworkError
ApiError({ message: 'Request failed' });  // OK
ApiError({ message: 'Request failed', cause: networkError });  // OK, type-checked!
// ApiError({ message: 'x', cause: validationError });  // Type error! wrong cause type
```

This encodes domain knowledge: "API errors fail because of network issues, not validation issues."

#### Required Cause: `.withCause<T>()` (without undefined)

For wrapper errors that must always have a cause:

```typescript
const { UnhandledError } = createTaggedError('UnhandledError')
  .withCause<AnyTaggedError>();

// Cause is REQUIRED
UnhandledError({ message: 'Unexpected error', cause: originalError });  // Must provide cause!
// UnhandledError({ message: 'Oops' });  // Type error! cause is required
```

### Combining Context and Cause

Chain both methods in any order:

```typescript
const { DbError } = createTaggedError('DbError');
type DbError = ReturnType<typeof DbError>;

const { RepoError, RepoErr } = createTaggedError('RepoError')
  .withContext<{ entity: string; operation: string }>()
  .withCause<DbError | undefined>();

// Context is required, cause is optional
RepoError({
  message: 'Failed to fetch user',
  context: { entity: 'User', operation: 'findById' }
});

RepoError({
  message: 'Failed to fetch user',
  context: { entity: 'User', operation: 'findById' },
  cause: dbError
});
```

### Quick Reference

```typescript
import { createTaggedError } from 'wellcrafted/error';

// 1. Flexible mode (default) - context and cause optional, loosely typed
const { NetworkError } = createTaggedError('NetworkError');

// 2. Required context - context required with exact shape
const { FileError } = createTaggedError('FileError')
  .withContext<{ path: string }>();

// 3. Optional typed context - context optional but typed when provided
const { LogError } = createTaggedError('LogError')
  .withContext<{ file: string; line: number } | undefined>();

// 4. Optional typed cause - cause optional but constrained when provided
const { ServiceError } = createTaggedError('ServiceError')
  .withCause<DbError | CacheError | undefined>();

// 5. Required cause - for wrapper errors
const { UnhandledError } = createTaggedError('UnhandledError')
  .withCause<AnyTaggedError>();

// 6. Both context and cause
const { ApiError } = createTaggedError('ApiError')
  .withContext<{ endpoint: string }>()
  .withCause<NetworkError | undefined>();
```

### Using in tryAsync/trySync

The factory pattern works seamlessly with error mapping:

```typescript
const { ApiError, ApiErr } = createTaggedError('ApiError')
  .withContext<{ endpoint: string }>();

const result = await tryAsync({
  try: () => fetch('/api/data').then(r => r.json()),
  catch: (error) => ApiErr({
    message: 'Failed to fetch data',
    context: { endpoint: '/api/data' },
    cause: error
  })
});
```

## Serialization Benefits

Unlike JavaScript's Error class, TaggedErrors are plain objects that serialize perfectly:

```typescript
const error: ValidationError = {
  name: "ValidationError",
  message: "Age must be between 0 and 150",
  context: { 
    field: "age",
    value: -5,
    constraints: { min: 0, max: 150 }
  },
  cause: undefined
};

// Perfect serialization
const serialized = JSON.stringify(error);
console.log(serialized);
// {"name":"ValidationError","message":"Age must be between 0 and 150",...}

// Perfect deserialization
const deserialized = JSON.parse(serialized);
// Still a valid TaggedError!
```

This enables:
- **API responses**: Send structured errors to clients
- **Logging**: Store complete error information
- **Worker communication**: Pass errors between threads
- **State persistence**: Save errors in localStorage or databases

## Best Practices

### 1. Include Meaningful Context

Always start with the function's input parameters:

```typescript
function createDbError(
  message: string,
  query: string,
  params: unknown[],
  cause: unknown
): DbError {
  return {
    name: "DbError",
    message,
    context: {
      query,        // Function input
      params,       // Function input
      timestamp: new Date().toISOString(),  // Additional context
      connectionPool: 'primary'             // Debugging info
    },
    cause,
  };
}
```

### 2. Make Errors Specific

Avoid generic error types:

```typescript
// ❌ Too generic
type Error = TaggedError<"Error">;

// ✅ Specific and actionable
type UserNotFoundError = TaggedError<"UserNotFoundError">;
type InvalidCredentialsError = TaggedError<"InvalidCredentialsError">;
type SessionExpiredError = TaggedError<"SessionExpiredError">;
```

### 3. Use Union Types for Function Signatures

Make all possible errors visible:

```typescript
function authenticateUser(
  credentials: Credentials
): Result<User, InvalidCredentialsError | UserNotFoundError | SessionExpiredError> {
  // Implementation makes it clear what can go wrong
}
```

### 4. Handle Errors at the Right Level

Transform errors where you can add context:

```typescript
async function getUserProfile(userId: string): Result<Profile, UserServiceError> {
  // Low-level database call
  const dbResult = await queryDatabase(`SELECT * FROM users WHERE id = ?`, [userId]);
  
  if (dbResult.error) {
    // Transform database error to domain error
    return Err({
      name: "UserServiceError",
      message: "Failed to fetch user profile",
      context: { 
        userId,
        operation: 'getUserProfile'
      },
      cause: dbResult.error  // Preserve original error
    });
  }
  
  return Ok(transformToProfile(dbResult.data));
}
```

### 5. Design for Debugging

Structure your errors to answer these questions:
- **What went wrong?** (message)
- **Where did it happen?** (name + stack trace in cause)
- **What data caused it?** (context with inputs)
- **What was the root cause?** (cause chain)

```typescript
function processPayment(order: Order, card: Card): Result<Receipt, PaymentError> {
  const validation = validateCard(card);
  if (validation.error) {
    return Err({
      name: "PaymentError",
      message: "Payment processing failed",
      context: {
        orderId: order.id,
        amount: order.total,
        cardLast4: card.number.slice(-4),  // Safe partial info
        validationError: validation.error.message
      },
      cause: validation.error
    });
  }
  // ... rest of implementation
}
```

## Error Handling Patterns

### Early Return Pattern

The most common and readable pattern:

```typescript
async function createOrder(input: OrderInput): Promise<Result<Order, OrderError>> {
  const userResult = await getUser(input.userId);
  if (userResult.error) return userResult;
  
  const validationResult = validateOrderInput(input);
  if (validationResult.error) return validationResult;
  
  const inventoryResult = await checkInventory(input.items);
  if (inventoryResult.error) return inventoryResult;
  
  // All checks passed, create the order
  return Ok(await saveOrder({
    user: userResult.data,
    items: inventoryResult.data,
    ...validationResult.data
  }));
}
```

### Error Aggregation

When you need to collect multiple errors:

```typescript
function validateForm(input: FormInput): Result<ValidatedForm, ValidationError[]> {
  const errors: ValidationError[] = [];
  
  if (!input.email?.includes('@')) {
    errors.push({
      name: "ValidationError",
      message: "Invalid email format",
      context: { field: 'email', value: input.email },
      cause: undefined
    });
  }
  
  if (!input.password || input.password.length < 8) {
    errors.push({
      name: "ValidationError",
      message: "Password must be at least 8 characters",
      context: { field: 'password' },
      cause: undefined
    });
  }
  
  if (errors.length > 0) {
    return Err(errors);
  }
  
  return Ok(input as ValidatedForm);
}
```

### Error Recovery

Implement retry logic with typed errors:

```typescript
async function fetchWithRetry<T>(
  url: string,
  maxRetries = 3
): Promise<Result<T, NetworkError>> {
  let lastError: NetworkError | null = null;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    const result = await tryAsync<T, NetworkError>({
      try: () => fetch(url).then(r => r.json()),
      catch: (error) => Err({
        name: "NetworkError",
        message: `Request failed (attempt ${attempt}/${maxRetries})`,
        context: { url, attempt, maxRetries },
        cause: error
      })
    });

    if (result.data) return result;
    
    lastError = result.error;
    
    // Exponential backoff
    if (attempt < maxRetries) {
      await new Promise(resolve => 
        setTimeout(resolve, Math.pow(2, attempt) * 1000)
      );
    }
  }

  return Err(lastError!);
}
```

## Integration with Result Type

TaggedErrors are designed to work seamlessly with the Result type:

```typescript
import { Result, Ok, Err, tryAsync } from "wellcrafted/result";
import { type TaggedError } from "wellcrafted/error";

type UserNotFoundError = TaggedError<"UserNotFoundError">;
type DatabaseError = TaggedError<"DatabaseError">;

async function getUser(id: string): Promise<Result<User, UserNotFoundError | DatabaseError>> {
  const result = await tryAsync<User, DatabaseError>({
    try: () => database.users.findById(id),
    catch: (error) => Err({
      name: "DatabaseError",
      message: "Database query failed",
      context: { userId: id, operation: 'findById' },
      cause: error
    })
  });
  
  if (result.error) return result;
  
  if (!result.data) {
    return Err({
      name: "UserNotFoundError",
      message: `User with ID ${id} not found`,
      context: { userId: id },
      cause: undefined
    });
  }
  
  return Ok(result.data);
}
```

## Summary

The TaggedError system transforms error handling from an afterthought to a first-class concern:

- **Structured**: Every error has a consistent shape
- **Serializable**: Works across all JavaScript boundaries
- **Type-safe**: Full TypeScript discrimination support
- **Debuggable**: Rich context for troubleshooting
- **Composable**: Errors can be wrapped and transformed

By treating errors as data rather than control flow, you gain predictability, testability, and maintainability in your error handling.

## See Also

<CardGroup>
  <Card title="Result Pattern Deep Dive" icon="code-branch" href="/core/result-pattern">
    Understand how TaggedErrors work with the Result discriminated union
  </Card>
  <Card title="Real-World Examples" icon="code" href="/patterns/real-world">
    See TaggedErrors in production authentication, validation, and API code
  </Card>
  <Card title="Service Layer Pattern" icon="layer-group" href="/patterns/service-layer">
    Learn error transformation patterns in service architecture
  </Card>
  <Card title="Framework Integrations" icon="plug" href="/integrations/svelte-tanstack">
    Use TaggedErrors with TanStack Query and other frameworks
  </Card>
</CardGroup>

<Note>
Ready to see TaggedErrors in action? Explore our [real-world patterns](/patterns/real-world) or check out the [service layer guide](/patterns/service-layer).
</Note>