---
title: 'Error System Design'
description: "Understanding wellcrafted's structured, serializable error system"
icon: 'triangle-exclamation'
---

# Error System Design

wellcrafted's error system is built on a simple yet powerful principle: **errors should be data, not control flow**. This page explains the design philosophy, implementation details, and best practices for creating robust error handling in your applications.

## The TaggedError Pattern

At the heart of wellcrafted's error system is the `TaggedError` type - a structured, serializable error representation that works seamlessly with TypeScript's type system.

### Why TaggedError?

Traditional JavaScript errors have fundamental problems:

1. **Serialization breaks them**: `JSON.stringify(new Error())` loses the message and stack trace
2. **No standardization**: Libraries throw strings, Error objects, custom classes, or even undefined
3. **Prototype chain complexity**: `instanceof` checks fail across different realms (iframes, workers)
4. **Poor TypeScript integration**: Can't discriminate between different error types in unions

TaggedError solves all these issues:

1. **JSON-serializable**: Plain objects that survive any serialization boundary
2. **Type-safe discrimination**: The `name` field acts as a discriminant for TypeScript
3. **Lightweight**: No overhead of class instantiation or prototype chains
4. **Structured context**: Enforces machine-readable debugging information

## The Four Properties of TaggedError

Every `TaggedError` contains four essential properties that work together to create a robust, debuggable error system:

```typescript
type TaggedError<T extends string> = {
  readonly name: T;                    // 1. The discriminant
  message: string;                     // 2. Human-readable description
  context?: JsonObject;                // 3. JSON-serializable debugging data
  cause?: TaggedError;                 // 4. Root cause (another TaggedError)
};
```

<Note>
The `context` property should include the function's input parameters and any relevant variables in the closure. This creates a complete picture of what data led to the error, making debugging straightforward.
</Note>

### 1. `name` - The Discriminant

This is your error's unique identifier and the key to pattern matching. Use it in `if` statements and `switch` statements to handle different error types:

```typescript
type ValidationError = TaggedError<"ValidationError">;
type NetworkError = TaggedError<"NetworkError">;
type FileError = TaggedError<"FileError">;

function handleError(error: ValidationError | NetworkError | FileError) {
  switch (error.name) {
    case "ValidationError":
      // TypeScript knows this is ValidationError
      console.log("Invalid input:", error.context);
      break;
    case "NetworkError": 
      // TypeScript knows this is NetworkError
      console.log("Network failed:", error.message);
      break;
    case "FileError":
      // TypeScript knows this is FileError
      console.log("File issue:", error.context);
      break;
  }
}
```

### 2. `message` - Human-Readable Text

Pure text description that explains what went wrong. Keep it clear and actionable:

```typescript
const { ValidationError, ValidationErr } = createTaggedError('ValidationError')
  .withContext<{ email: string }>()
  .withMessage(({ context }) => `Email address "${context.email}" must contain an @ symbol`);

return ValidationErr({ context: { email: userInput } });
```

### 3. `context` - Function Inputs & Debugging Data

The primary purpose of `context` is to capture the function's input parameters, relevant variables in the closure, and additional context:

```typescript
const { ProcessError, ProcessErr } = createTaggedError('ProcessError')
  .withContext<{ userId: number; options: UserOptions; timestamp: string; retryCount: number }>()
  .withMessage(() => 'User processing failed');

function processUser(id: number, options: UserOptions): Result<User, ProcessError> {
  return ProcessErr({
    context: {
      userId: id,           // Function input
      options,              // Function input
      timestamp: new Date().toISOString(),  // Additional context
      retryCount: 3         // Useful debugging info
    }
  });
}
```

### 4. `cause` - JSON-Serializable Call Stack

The `cause` property accepts another `TaggedError`, enabling error chaining. This creates a **JSON-serializable call stack** that traces how an error propagated through your application layers:

```typescript
// Define errors for each layer
const { NetworkError, NetworkErr } = createTaggedError('NetworkError')
  .withContext<{ host: string; port: number; timeout: number }>()
  .withMessage(({ context }) => `Socket timeout after ${context.timeout}ms`);
type NetworkError = ReturnType<typeof NetworkError>;

const { DatabaseError, DatabaseErr } = createTaggedError('DatabaseError')
  .withContext<{ operation: string; retries: number }>()
  .withCause<NetworkError>()
  .withMessage(() => 'Failed to connect to database');
type DatabaseError = ReturnType<typeof DatabaseError>;

const { UserServiceError, UserServiceErr } = createTaggedError('UserServiceError')
  .withContext<{ userId: string; method: string }>()
  .withCause<DatabaseError>()
  .withMessage(() => 'Could not fetch user profile');
type UserServiceError = ReturnType<typeof UserServiceError>;

const { APIError, APIErr } = createTaggedError('APIError')
  .withContext<{ endpoint: string; statusCode: number }>()
  .withCause<UserServiceError>()
  .withMessage(() => 'Internal server error');

// Low-level network error
const networkError = NetworkError({
  context: { host: "db.example.com", port: 5432, timeout: 5000 }
});

// Wrapped by database layer
const dbError = DatabaseError({
  context: { operation: "connect", retries: 3 },
  cause: networkError
});

// Wrapped by service layer
const serviceError = UserServiceError({
  context: { userId: "123", method: "getUserById" },
  cause: dbError
});

// Wrapped by API handler
const apiError = APIError({
  context: { endpoint: "/api/users/123", statusCode: 500 },
  cause: serviceError
});

// The entire error chain is JSON-serializable!
console.log(JSON.stringify(apiError, null, 2));
```

**The serialized output shows the complete call stack:**

```json
{
  "name": "APIError",
  "message": "Internal server error",
  "context": {
    "endpoint": "/api/users/123",
    "statusCode": 500
  },
  "cause": {
    "name": "UserServiceError",
    "message": "Could not fetch user profile",
    "context": {
      "userId": "123",
      "method": "getUserById"
    },
    "cause": {
      "name": "DatabaseError",
      "message": "Failed to connect to database",
      "context": {
        "operation": "connect",
        "retries": 3
      },
      "cause": {
        "name": "NetworkError",
        "message": "Socket timeout after 5000ms",
        "context": {
          "host": "db.example.com",
          "port": 5432,
          "timeout": 5000
        }
      }
    }
  }
}
```

You can traverse this error chain in either direction:
- **Top-down**: Start at the API error and drill into the root cause
- **Bottom-up**: Each layer wraps the layer below, preserving the full context

This chaining pattern provides:
- **Complete error trace**: See exactly how an error bubbled up through your stack
- **Layer-specific context**: Each layer adds its own debugging information
- **JSON-serializable**: Unlike JavaScript stack traces, this survives any serialization
- **Type-safe**: Each error in the chain maintains full TypeScript typing

For simple errors without an underlying cause, omit the `cause` property entirely:

```typescript
const { ValidationErr } = createTaggedError('ValidationError')
  .withContext<{ email: string }>()
  .withMessage(() => 'Invalid email format');

return ValidationErr({ context: { email: userInput } });
// No cause - this is where the error originated
```

## Creating Domain-Specific Errors

Define a set of possible errors for each domain in your application:

```typescript
// Define your specific error types
export type FileNotFoundError = TaggedError<"FileNotFoundError">;
export type PermissionDeniedError = TaggedError<"PermissionDeniedError">;
export type DiskFullError = TaggedError<"DiskFullError">;

// Create a union of all possible errors for this domain
export type FileSystemError = 
  | FileNotFoundError 
  | PermissionDeniedError 
  | DiskFullError;

// Use createTaggedError to define factories
const { FileNotFoundErr } = createTaggedError('FileNotFoundError')
  .withContext<{ path: string }>()
  .withCause<AnyTaggedError | undefined>()
  .withMessage(({ context }) => `The file at path "${context.path}" was not found`);
```

## The createTaggedError API

wellcrafted provides a fluent `createTaggedError` builder that eliminates boilerplate and enforces consistent error structure. The builder requires `.withMessage(fn)` as its **final step** — this is what gives you the factory functions.

```typescript
import { createTaggedError } from "wellcrafted/error";

// Define your error — .withMessage() is required and returns the factories
const { NetworkError, NetworkErr } = createTaggedError('NetworkError')
  .withMessage(() => 'Network request failed');

// Extract the type using ReturnType
type NetworkError = ReturnType<typeof NetworkError>;

// Two factory functions are created:
// - NetworkError({ context?, cause? }): Creates plain error object
// - NetworkErr({ context?, cause? }): Creates Err-wrapped error (for Result returns)
```

### `.withMessage(fn)` — Required and Terminal

`.withMessage(fn)` is the **terminal step** of the builder. It accepts a function that receives `{ name, context?, cause? }` and returns the error message string. Factories are only available after calling it.

```typescript
const { FileError, FileErr } = createTaggedError('FileError')
  .withContext<{ path: string; operation: 'read' | 'write' | 'delete' }>()
  .withMessage(({ context }) => `${context.operation} failed for ${context.path}`);

// Message is auto-computed from the template at call time
FileErr({ context: { path: '/etc/passwd', operation: 'write' } });
// → { name: 'FileError', message: 'write failed for /etc/passwd', context: { ... } }
```

<Note>
Factories are only available on the object returned by `.withMessage()`. The builder returned by `.withContext()` and `.withCause()` does **not** have factory methods — you must call `.withMessage()` first.
</Note>

### Context Constraints: `.withContext<T>()`

Use `.withContext<T>()` to enforce the shape of debugging data.

#### Required Context

When you know what information is **always** needed:

```typescript
const { FileError, FileErr } = createTaggedError('FileError')
  .withContext<{ path: string; operation: 'read' | 'write' | 'delete' }>()
  .withMessage(({ context }) => `${context.operation} failed for ${context.path}`);

// context is REQUIRED — TypeScript enforces it
FileErr({ context: { path: '/etc/passwd', operation: 'write' } });
// FileErr();  // Type error! context is required
```

#### Optional Typed Context

Include `undefined` in the type when context isn't always available:

```typescript
const { LogError, LogErr } = createTaggedError('LogError')
  .withContext<{ file: string; line: number } | undefined>()
  .withMessage(() => 'Log parse failed');

// context is optional
LogErr();

// When provided, it's fully typed
LogErr({ context: { file: 'app.ts', line: 42 } });
// LogErr({ context: { wrong: true } });  // Type error! wrong shape
```

### Cause Constraints: `.withCause<T>()`

Encode domain knowledge about what errors can cause this one.

#### Optional Typed Cause

```typescript
const { NetworkError, NetworkErr } = createTaggedError('NetworkError')
  .withMessage(() => 'Network request failed');
type NetworkError = ReturnType<typeof NetworkError>;

const { ApiError, ApiErr } = createTaggedError('ApiError')
  .withCause<NetworkError | undefined>()
  .withMessage(() => 'API call failed');

// cause is optional but type-constrained when provided
ApiErr();  // OK
ApiErr({ cause: networkError });  // OK, type-checked!
// ApiErr({ cause: validationError });  // Type error! wrong cause type
```

#### Required Cause

For wrapper errors that must always wrap another:

```typescript
const { UnhandledError, UnhandledErr } = createTaggedError('UnhandledError')
  .withCause<AnyTaggedError>()
  .withMessage(({ cause }) => `Unhandled error: ${cause.message}`);

// cause is REQUIRED
UnhandledErr({ cause: originalError });
// UnhandledErr();  // Type error! cause is required
```

### Combining Context and Cause

Chain `.withContext()` and `.withCause()` in any order before `.withMessage()`:

```typescript
const { DbError, DbErr } = createTaggedError('DbError')
  .withMessage(() => 'Database query failed');
type DbError = ReturnType<typeof DbError>;

const { RepoError, RepoErr } = createTaggedError('RepoError')
  .withContext<{ entity: string; operation: string }>()
  .withCause<DbError | undefined>()
  .withMessage(({ context }) => `${context.operation} failed for ${context.entity}`);

// Both provided
RepoErr({
  context: { entity: 'User', operation: 'findById' },
  cause: dbError
});

// Cause is optional (because of | undefined)
RepoErr({ context: { entity: 'User', operation: 'findById' } });
```

### Context Must Be JSON-Serializable

`context` must conform to `JsonObject` — all values must be JSON-serializable primitives, arrays, or nested objects. This ensures errors survive any serialization boundary.

```typescript
// ✅ Valid JsonObject context
FileErr({ context: { path: '/etc/passwd', size: 1024, tags: ['system'] } });

// ❌ Not allowed — Date, functions, class instances are not JSON-serializable
FileErr({ context: { createdAt: new Date(), handler: () => {} } });  // Type error!
```

### Extracting the Error Type

Use `ReturnType<typeof FactoryFn>` to get the TypeScript type for a factory:

```typescript
const { NetworkError, NetworkErr } = createTaggedError('NetworkError')
  .withContext<{ url: string; status: number }>()
  .withMessage(({ context }) => `Request to ${context.url} failed with ${context.status}`);

type NetworkError = ReturnType<typeof NetworkError>;
// NetworkError = TaggedError<'NetworkError', { url: string; status: number }, undefined>
```

### Quick Reference

```typescript
import { createTaggedError } from 'wellcrafted/error';

// Minimal — just a message template
const { NetworkError, NetworkErr } = createTaggedError('NetworkError')
  .withMessage(() => 'Network request failed');

// Required context
const { FileError, FileErr } = createTaggedError('FileError')
  .withContext<{ path: string }>()
  .withMessage(({ context }) => `File operation failed: ${context.path}`);

// Optional typed context
const { LogError, LogErr } = createTaggedError('LogError')
  .withContext<{ file: string; line: number } | undefined>()
  .withMessage(() => 'Log parse failed');

// Optional typed cause
const { ServiceError, ServiceErr } = createTaggedError('ServiceError')
  .withCause<DbError | CacheError | undefined>()
  .withMessage(() => 'Service operation failed');

// Required cause
const { UnhandledError, UnhandledErr } = createTaggedError('UnhandledError')
  .withCause<AnyTaggedError>()
  .withMessage(({ cause }) => `Unhandled: ${cause.message}`);

// Context + cause
const { ApiError, ApiErr } = createTaggedError('ApiError')
  .withContext<{ endpoint: string }>()
  .withCause<NetworkError | undefined>()
  .withMessage(({ context }) => `API call failed: ${context.endpoint}`);

// Extract types
type NetworkError = ReturnType<typeof NetworkError>;
type FileError = ReturnType<typeof FileError>;
```

### Using in tryAsync/trySync

The factory pattern works seamlessly with error mapping. Pass `context` and `cause` at the call site — the message is auto-computed by `.withMessage()`:

```typescript
const { ApiError, ApiErr } = createTaggedError('ApiError')
  .withContext<{ endpoint: string }>()
  .withCause()
  .withMessage(({ context }) => `Failed to fetch data from ${context.endpoint}`);

const result = await tryAsync({
  try: () => fetch('/api/data').then(r => r.json()),
  catch: (error) => ApiErr({
    context: { endpoint: '/api/data' },
    cause: error
  })
});
```

## Serialization Benefits

Unlike JavaScript's Error class, TaggedErrors are plain objects that serialize perfectly:

```typescript
const { ValidationError } = createTaggedError('ValidationError')
  .withContext<{ field: string; value: number; constraints: { min: number; max: number } }>()
  .withMessage(({ context }) => `${context.field} must be between ${context.constraints.min} and ${context.constraints.max}`);

const error = ValidationError({
  context: { field: "age", value: -5, constraints: { min: 0, max: 150 } }
});

// Perfect serialization
const serialized = JSON.stringify(error);
console.log(serialized);
// {"name":"ValidationError","message":"age must be between 0 and 150",...}

// Perfect deserialization
const deserialized = JSON.parse(serialized);
// Still a valid TaggedError!
```

This enables:
- **API responses**: Send structured errors to clients
- **Logging**: Store complete error information
- **Worker communication**: Pass errors between threads
- **State persistence**: Save errors in localStorage or databases

## Best Practices

### 1. Include Meaningful Context

Always start with the function's input parameters:

```typescript
const { DbError, DbErr } = createTaggedError('DbError')
  .withContext<{ query: string; params: unknown[]; timestamp: string; connectionPool: string }>()
  .withCause<AnyTaggedError | undefined>()
  .withMessage(({ context }) => `Database query failed: ${context.query}`);

// At the call site — context captures function inputs and debugging info
DbErr({
  context: {
    query: 'SELECT * FROM users WHERE id = ?',  // Function input
    params: [userId],                             // Function input
    timestamp: new Date().toISOString(),          // Additional context
    connectionPool: 'primary'                     // Debugging info
  },
  cause: originalError
});
```

### 2. Make Errors Specific

Avoid generic error types:

```typescript
// ❌ Too generic
type Error = TaggedError<"Error">;

// ✅ Specific and actionable
type UserNotFoundError = TaggedError<"UserNotFoundError">;
type InvalidCredentialsError = TaggedError<"InvalidCredentialsError">;
type SessionExpiredError = TaggedError<"SessionExpiredError">;
```

### 3. Use Union Types for Function Signatures

Make all possible errors visible:

```typescript
function authenticateUser(
  credentials: Credentials
): Result<User, InvalidCredentialsError | UserNotFoundError | SessionExpiredError> {
  // Implementation makes it clear what can go wrong
}
```

### 4. Handle Errors at the Right Level

Transform errors where you can add context:

```typescript
const { UserServiceErr } = createTaggedError('UserServiceError')
  .withContext<{ userId: string; operation: string }>()
  .withCause<DbError>()
  .withMessage(({ context }) => `Failed to ${context.operation}`);

async function getUserProfile(userId: string): Result<Profile, UserServiceError> {
  // Low-level database call
  const dbResult = await queryDatabase(`SELECT * FROM users WHERE id = ?`, [userId]);

  if (dbResult.error) {
    // Transform database error to domain error
    return UserServiceErr({
      context: { userId, operation: 'getUserProfile' },
      cause: dbResult.error  // Preserve original error
    });
  }

  return Ok(transformToProfile(dbResult.data));
}
```

### 5. Design for Debugging

Structure your errors to answer these questions:
- **What went wrong?** (message)
- **Where did it happen?** (name + stack trace in cause)
- **What data caused it?** (context with inputs)
- **What was the root cause?** (cause chain)

```typescript
const { PaymentErr } = createTaggedError('PaymentError')
  .withContext<{ orderId: string; amount: number; cardLast4: string }>()
  .withCause<CardValidationError>()
  .withMessage(() => 'Payment processing failed');

function processPayment(order: Order, card: Card): Result<Receipt, PaymentError> {
  const validation = validateCard(card);
  if (validation.error) {
    return PaymentErr({
      context: {
        orderId: order.id,
        amount: order.total,
        cardLast4: card.number.slice(-4),  // Safe partial info
      },
      cause: validation.error
    });
  }
  // ... rest of implementation
}
```

## Error Handling Patterns

### Early Return Pattern

The most common and readable pattern:

```typescript
async function createOrder(input: OrderInput): Promise<Result<Order, OrderError>> {
  const userResult = await getUser(input.userId);
  if (userResult.error) return userResult;
  
  const validationResult = validateOrderInput(input);
  if (validationResult.error) return validationResult;
  
  const inventoryResult = await checkInventory(input.items);
  if (inventoryResult.error) return inventoryResult;
  
  // All checks passed, create the order
  return Ok(await saveOrder({
    user: userResult.data,
    items: inventoryResult.data,
    ...validationResult.data
  }));
}
```

### Error Aggregation

When you need to collect multiple errors:

```typescript
const { ValidationError } = createTaggedError('ValidationError')
  .withContext<{ field: string; value?: string }>()
  .withMessage(({ context }) => `Validation failed for field "${context.field}"`);
type ValidationError = ReturnType<typeof ValidationError>;

function validateForm(input: FormInput): Result<ValidatedForm, ValidationError[]> {
  const errors: ValidationError[] = [];

  if (!input.email?.includes('@')) {
    errors.push(ValidationError({ context: { field: 'email', value: input.email } }));
  }

  if (!input.password || input.password.length < 8) {
    errors.push(ValidationError({ context: { field: 'password' } }));
  }

  if (errors.length > 0) {
    return Err(errors);
  }

  return Ok(input as ValidatedForm);
}
```

### Error Recovery

Implement retry logic with typed errors:

```typescript
const { NetworkError, NetworkErr } = createTaggedError('NetworkError')
  .withContext<{ url: string; attempt: number; maxRetries: number }>()
  .withCause()
  .withMessage(({ context }) => `Request failed (attempt ${context.attempt}/${context.maxRetries})`);
type NetworkError = ReturnType<typeof NetworkError>;

async function fetchWithRetry<T>(
  url: string,
  maxRetries = 3
): Promise<Result<T, NetworkError>> {
  let lastError: NetworkError | null = null;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    const result = await tryAsync<T, NetworkError>({
      try: () => fetch(url).then(r => r.json()),
      catch: (error) => NetworkErr({
        context: { url, attempt, maxRetries },
        cause: error
      })
    });

    if (result.data) return result;
    
    lastError = result.error;
    
    // Exponential backoff
    if (attempt < maxRetries) {
      await new Promise(resolve => 
        setTimeout(resolve, Math.pow(2, attempt) * 1000)
      );
    }
  }

  return Err(lastError!);
}
```

## Integration with Result Type

TaggedErrors are designed to work seamlessly with the Result type:

```typescript
import { Result, Ok, Err, tryAsync } from "wellcrafted/result";
import { createTaggedError } from "wellcrafted/error";

const { DatabaseError, DatabaseErr } = createTaggedError('DatabaseError')
  .withContext<{ userId: string; operation: string }>()
  .withCause()
  .withMessage(({ context }) => `Database ${context.operation} failed`);
type DatabaseError = ReturnType<typeof DatabaseError>;

const { UserNotFoundError, UserNotFoundErr } = createTaggedError('UserNotFoundError')
  .withContext<{ userId: string }>()
  .withMessage(({ context }) => `User with ID ${context.userId} not found`);
type UserNotFoundError = ReturnType<typeof UserNotFoundError>;

async function getUser(id: string): Promise<Result<User, UserNotFoundError | DatabaseError>> {
  const result = await tryAsync<User, DatabaseError>({
    try: () => database.users.findById(id),
    catch: (error) => DatabaseErr({
      context: { userId: id, operation: 'findById' },
      cause: error
    })
  });

  if (result.error) return result;

  if (!result.data) {
    return UserNotFoundErr({ context: { userId: id } });
  }

  return Ok(result.data);
}
```

## Summary

The TaggedError system transforms error handling from an afterthought to a first-class concern:

- **Structured**: Every error has a consistent shape
- **Serializable**: Works across all JavaScript boundaries
- **Type-safe**: Full TypeScript discrimination support
- **Debuggable**: Rich context for troubleshooting
- **Composable**: Errors can be wrapped and transformed

By treating errors as data rather than control flow, you gain predictability, testability, and maintainability in your error handling.

## See Also

<CardGroup>
  <Card title="Result Pattern Deep Dive" icon="code-branch" href="/core/result-pattern">
    Understand how TaggedErrors work with the Result discriminated union
  </Card>
  <Card title="Real-World Examples" icon="code" href="/patterns/real-world">
    See TaggedErrors in production authentication, validation, and API code
  </Card>
  <Card title="Service Layer Pattern" icon="layer-group" href="/patterns/service-layer">
    Learn error transformation patterns in service architecture
  </Card>
  <Card title="Framework Integrations" icon="plug" href="/integrations/svelte-tanstack">
    Use TaggedErrors with TanStack Query and other frameworks
  </Card>
</CardGroup>

<Note>
Ready to see TaggedErrors in action? Explore our [real-world patterns](/patterns/real-world) or check out the [service layer guide](/patterns/service-layer).
</Note>